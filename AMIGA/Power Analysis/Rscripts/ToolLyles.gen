" Simulation settings "
scalar    cvBlock ; 10
scalar    cvComparator ; 110

scalar    lowerLOC ; 0.5
scalar    upperLOC ; 2.0
scalar    ngridLOC ; 5
variate   nBlocks ; !(2,3,4)
scalar    ndatasets ; 1
scalar    nGCI ; 10000            " Number of draws for Gen. Conf. Interval "
scalar    alfa ; 0.05
scalar    limPowerDiff ; 2
scalar    minimumSum ; 0.999      " Minimum sum for probs for each mean "
scalar    seed ; 342894

scalar    power ; 1.5
text      distribution ; 'power'
text      distribution ; 'poisson'
text      distribution ; 'opoisson'
text      distribution ; 'negative'

text      design ; 'randomized'
text      design ; 'splitplot'
text      design ; 'block'

text      models ; !t(LN,NB)
text      models ; !t(LN,SQ,OP)
text      models ; !t(LN,SQ,OP,NB)
text      models ; !t(LN,SQ)
text      models ; !t(LN,SQ,OP)
text      models ; !t(LN,SQ,OP,NB)

" Some extra options "
scalar    mis
calculate init = urand(seed ; 1)
setoption [fit] nomessage ; !t(res,lev,disp)
setoption [add] nomessage ; !t(res,lev,disp)
setoption [r2negbinomial] nomessage ; !t(warnings)
variate   perc ; 100 * (!(0,1) + !(1,-1)*alfa/2)

" Import Data from Simulation tool "
text      file ; 'M:/My Documents/SmallMeans-0.csv'
import    file ; isave=isave
print     Variety, Ranking, Spraying, Comparison, Mean ; deci=4(0),2

" Define treatments as factors "
txconstru [tsave] isave
calculate posfactor[1,2] = position('Variety','Mean' ; tsave)  - (0,1)
variate   ifactor ; !(posfactor[1]...posfactor[2]) ; decimals=0
calculate nfactor = nvalues(ifactor)
groups    [redefine=yes] isave[#ifactor]

" Redefine ordering of factor labels of Variety; this ensures that dum[1]
  defines the parameter of interest "
calculate nLevelsVariety = nlevels(Variety)
if nLevelsVariety.gt.2
    getattrib [attribute=labels] Variety ; save=labVariety
    subset    [labVariety[].ni.!t(GMO,Comparator)] labVariety[] ; newlabels
    text      newlabels ; !t(GMO,Comparator,#newlabels)
  else
    text    newlabels ; !t(GMO,Comparator)
endif
facamend  Variety  ; newlabels
tabulate  [class=Variety ; print=count]

" Define blocks as factors "
groups    [redefine=yes] Block, MainPlot, SubPlot
calculate nplots = nvalues(Block)

" Define comparison "
variate   comparison ; (Comparison.in.'IncludeGMO') - \
          (Comparison.in.'IncludeComparator') ; decimals=0
restrict  Mean ; abs(comparison)
calculate meanComparator = mean(Mean)
restrict  Mean
print meanComparator

" Determine interaction factors and create dummies for Interaction*Variety "
calculate nInteractions = mean(NumberOfInteractions)
variate   cond ; !(1...#nfactor)
subset    [((cond-1).le.nInteractions)] ifactor ; intfactor
pointer   [values=isave[#intfactor]] intfactors
facproduc intfactors ; Interactions
calculate dum[1] = comparison.in.1
if sum(comparison.eq.0)
  subset    [comparison.eq.0 ; setlevels=yes] Interactions ; subInteractions
  getattrib [attribute=levels,labels] subInteractions ; save=levels
  scalar    counter ; 1
  for ll=#levels['levels']
    calculate counter = counter + 1
    calculate dum[counter] = Interactions.in.ll
  endfor
endif
calculate ndum,ndum1 = nvalues(dum) - (0,1)
variate   [modify=yes] dum[] ; decimals=0
if 1  " Printing of dummies for interaction "
  calculate nn = nvalues(intfactors)+1
  print     intfactors[], comparison, dum[] ; field=#nn(12), #ndum(7)
endif

" Determine Modifiers "
calculate nModifiers = mean(NumberOfModifiers)
if nModifiers
  subset    [ifactor.ni.intfactor] ifactor ; modfactor
  pointer   [values=isave[#modfactor]] modfactors
  facproduc modfactors ; Modifiers
  tabulate  [class=Modifiers] Mean ; mean=meanModifier
  if variance(meanModifier).eq.0
      " It is NOT a true modifier "
    calculate nModifiers = 0
  endif
endif
if 1*nModifiers  " Printing of dummies for modifiers "
  print     modfactors[], Modifiers ; field=12
endif

" Deal with distribution and Calculate overdispersion factor "
calculate cvPO = sqrt(Mean)/Mean
calculate sig2OP = (cvComparator/100)**2 * meanComparator
calculate cvOP = 100*sqrt(sig2OP*Mean)/Mean
calculate sig2NB = (cvComparator/100)**2 - 1/meanComparator
calculate cvNB = 100*sqrt(Mean + sig2NB*Mean*Mean)/Mean
calculate sig2PW = (cvComparator/100)**2 * meanComparator**(2-power)
calculate cvPW = 100*sqrt(sig2PW*Mean**power)/Mean
print     Mean, cvPO, cvOP, cvNB, cvPW
text      dist ; distribution
if distribution.eqs.'negative'
    calculate sig2, cvmean = sig2NB, cvNB
    expressio evar ; !e(kvar = kmean + ksig2*kmean*kmean)
  elsif distribution.eqs.'opoisson'
    calculate sig2, cvmean = sig2OP, cvOP
    expressio evar ; !e(kvar = ksig2*kmean)
  elsif distribution.eqs.'power'
    calculate cvmean = cvPW
    calculate sig2 = sig2PW*Mean**(power-2) - 1/Mean
    text      dist ; 'negative'
    expressio evar ; !e(kvar = kmean + ksig2*kmean*kmean)
  elsif distribution.eqs.'poisson'
    calculate sig2,cvmean = mis,cvPO
    text      dist ; 'poisson'
    expressio evar ; !e(kvar = kmean)
  else
    fault     [diag=fault ; expl=!t('Wrong setting of distribution')]
endif

" Deal with blocking random effect "
if design.eqs.'randomized'
    calculate sig2Block = 0
  elsif design.eqs.'block'
    calculate sig2Block = log((cvBlock/100)**2 + 1)
  elsif design.eqs.'splitplot'
    fault   [expl=!t('Misspecification of design')]
  else
    fault   [expl=!t('Misspecification of design')]
endif
calculate sigBlock = sqrt(sig2Block)
print     dist, sig2, sig2Block

" Print effective replication "
calculate nCMP = sum(abs(comparison)) - (nGMO = sum(dum[1]))
variate   nRepsGMO, nRepsCMP ; nGMO,nCMP*nBlocks ; deci=0
print     nBlocks, nRepsGMO, nRepsCMP ; decimals=0

" Create grid for looping Loop over Loc/nBlocks values "
calculate loglowerLOC, logupperLOC = log(lowerLOC, upperLOC)
fgrid     [minimum=loglowerLOC ; maximum=logupperLOC ; ngrid=ngridLOC] gridLOC
calculate gridLOC[] = exp(gridLOC[])
fgrid     [values=gridLOC[], nBlocks] grid
variate   LOC, nReps ; grid[] ; deci=*,0
decimals  LOC

calculate critvalChi = edchi(1-alfa ; 1)


" Structures to store results "
calculate doLN, doSQ, doOP, doNB = 'LN', 'SQ', 'OP', 'NB' .in. models
calculate nloop = nvalues(LOC)
variate   [nvalues=nloop ; values=#nloop(*)] powPO, powLN, powSQ, powOP, powNB, \
          powOPe, powLNe, powSQe, powNBe ; deci=3
variate   [nvalues=nloop ; values=#nloop(*)] meanVarLN, meanVarSQ, meanVarOP

" Structures to obtain prediction for GCI "
if (ndum1)
    pointer   [values=!(1,0), #ndum1(0)] predval
  else
    pointer   [values=!(1,0)] predval
endif
scalar    logGMO, logCMP, sqrGMO, sqrCMP, nGMO, nCMP

" Main looping "
for [ntimes=nloop ; index=ii]

  " Create Design for number of reps "
  scalar    iiLOC, iiReps ; (LOC, nReps)$[ii]
  calculate iiplots = iiReps*nplots
  factor    [nvalues=iiplots ; levels=iiReps] qBlock
  factor    [nvalues=iiplots ; levels=nplots] qPlot
  generate  qBlock, qPlot
  variate   [nvalues=iiReps] ranBlock
  pointer   [nvalues=ndum] qdum, zdum
  variate   [nvalues=iiplots] qdum[], qmean, qcomparison, qsig2
  equate    Mean, comparison, sig2, dum[] ; qmean, qcomparison, qsig2, qdum[]
  \print     qdum[] ; deci=0

  " Apply LOC effect"
  calculate qmean = ((1-qdum[1]) + qdum[1]*iiLOC) * qmean

  " Apply Blocking effect by means of Blom scores "
  if design.eqs.'block'
    variate   [values=1...#iiReps] blockeff
    calculate blockeff = exp(sigBlock*ned((blockeff-0.375)/(iiReps+0.25)))
    calculate qmean = qmean * newlevels(qBlock ; blockeff)
  endif

  " Loop over individual means to generate Lyles synthetic dataset "
  calculate nmean = nvalues(qmean)
  pointer   [nvalues=nmean] yy, ww
  variate   [nvalues=nmean] nobs, sumww, factor, qvar, eeLN, vvLN, eeSQ, vvSQ ; \
            decimals=0,4,0,5(*)
  for [ntimes=nmean ; index=kk]
    scalar    kmean, ksig2 ; (qmean,qsig2)$[kk]
    calculate #evar
    calculate qvar$[kk] = kvar
    calculate ksd = sqrt(kvar)
    for ff=5,6,7,8,9,10
      calculate factor$[kk] = ff
      calculate lowcount = bound(floor(kmean - ff*ksd) ; 0 ; mis)
      calculate uppcount = ceiling(kmean + ff*ksd)
      calculate nobs$[kk] = uppcount - lowcount + 1
      variate   [values=#lowcount...#uppcount] yy[kk], ww[kk]
      cntprobab [dist=#dist] yy[kk] ; mean=kmean ; disp=ksig2 ; prob=ww[kk]
      calculate ksumww = sum(ww[kk])
      exit      [control=for] (ksumww.gt.minimumSum)
    endfor
    calculate sumww$[kk] = ksumww
    " For LN "
    calculate ee1 = sum(ww[kk] * log(yy[kk]+1))
    calculate vv1 = sum(ww[kk] * (log(yy[kk]+1)-ee1)**2)
    calculate (eeLN,vvLN)$[kk] = ee1, vv1
    calculate ee1 = sum(ww[kk] * sqrt(yy[kk]))
    calculate vv1 = sum(ww[kk] * (sqrt(yy[kk])-ee1)**2)
    calculate (eeSQ,vvSQ)$[kk] = ee1, vv1
  endfor
  calculate (meanVarLN, meanVarSQ)$[ii] = mean(vvLN, vvSQ)
  calculate meanVarOP$[ii] = mean(qvar/qmean)
  \print     qmean, factor, nobs, sumww, vvLN
  variate   response, weight ; !(#yy), !(#ww)

  " Expand design and define model "
  fexpand   !(1...#nmean) ; nobs=nobs ; factor=id
  factor    [modify=yes] id ; decimals=0
  fexpand   qdum[] ; nobs=nobs ; variate=zdum[]
  variate   [modify=yes] zdum[] ; decimals=0
  fclassifi [out=modelH1] zdum[]

  if nModifiers
    duplicate Modifiers ; qModifiers ; values=!((#Modifiers)#iiReps)
    fexpand   !(#qModifiers) ; nobs=nobs ; factor=zModifiers
    factor    [modify=yes] zModifiers ; decimals=0
    fclassifi [out=modelH1] #modelH1 + zModifiers
  endif

  if design.eqs.'block'
    fexpand   !(#qBlock) ; nobs=nobs ; factor=zBlock
    factor    [modify=yes] zBlock ; decimals=0
    fclassifi [out=modelH1] #modelH1 + zBlock
  endif
  fclassifi [out=modelH0] #modelH1 - zdum[1]

  " Ready to fit the models "
  " LN: logarithmic transformation "
  variate   tresponse ; log(response+1)
  calculate meanVariance = mean(vvLN)
  model     [dist=normal ; dispersion=meanVariance ; weight=weight] tresponse
  terms     #modelH1
  fit       [print=* ; nomes=lev,res,disp] #modelH1
  rkeep     dev=dev1 ; df=df1
  drop      [print=* ; nomes=lev,res,disp] zdum[1]
  rkeep     dev=dev0 ; df=df0
  calculate noncentral = bound((dev0-dev1)/meanVariance ; 0 ; mis)
  calculate powLN$[ii] = (power = cuchi(critvalChi ; 1 ; noncentral))

  " SQ: squared root transformation "
  variate   tresponse ; sqrt(response)
  calculate meanVariance = mean(vvSQ)
  model     [dist=normal ; dispersion=meanVariance ; weight=weight] tresponse
  terms     #modelH1
  fit       [print=* ; nomes=lev,res,disp] #modelH1
  rkeep     dev=dev1 ; df=df1
  drop      [print=* ; nomes=lev,res,disp] zdum[1]
  rkeep     dev=dev0 ; df=df0
  calculate noncentral = bound((dev0-dev1)/meanVariance ; 0 ; mis)
  calculate powSQ$[ii] = (power = cuchi(critvalChi ; 1 ; noncentral))

  " PO: Poisson "
  model     [dist=poisson ; link=log ; weight=weight] response
  terms     #modelH1
  fit       [print=* ; nomes=lev,res,disp] #modelH1
  rkeep     dev=dev1 ; df=df1
  drop      [print=* ; nomes=lev,res,disp] zdum[1]
  rkeep     dev=dev0 ; df=df0
  calculate noncentral = bound(dev0 - dev1 ; 0 ; mis)
  calculate powPO$[ii] = (power = cuchi(critvalChi ; 1 ; noncentral))
  print     noncentral, power

  " OP: overdipsersed Poisson "
  " Note that OP needs not to be fitted because deviances are identical to PO "
  calculate meanVariance = mean(qvar/qmean)
  model     [dist=poisson ; dispersion=meanVariance ; weight=weight] response
  terms     #modelH1
  fit       [print=* ; nomes=lev,res,disp] #modelH1
  rkeep     dev=dev1 ; df=df1
  drop      [print=* ; nomes=lev,res,disp] zdum[1]
  rkeep     dev=dev0 ; df=df0
  calculate noncentral = bound((dev0-dev1)/meanVariance ; 0 ; mis)
  calculate powOP$[ii] = (power = cuchi(critvalChi ; 1 ; noncentral))
  print     noncentral, power

  " NB: negative binomial "
  calculate dev0,dev1 = mis
  model     [dist=negative ; link=log ; weight=weight] response
  r2negbin  [print=* ; _2log=dev1] #modelH1
  rkeep     exit=exit ; esti=esti
  calculate effGMO = esti$[1]
  r2negbin  [print=* ; _2log=dev0] #modelH0
  calculate noncentral = bound(dev0 - dev1 ; 0 ; mis)
  calculate powNB$[ii] = (power = cuchi(critvalChi ; 1 ; noncentral))
  print     noncentral, power
endfor
print   LOC, nReps, meanVarLN, meanVarSQ, meanVarOP

groups  LOC ; fLOC ; levels=levLOC
for [index=ii] ll=#levLOC
  restrict  nReps ; fLOC.eq.ll
  if (ii.eq.1)
      text      iprint ; 'id'
      skip      [filetype=output] 1
    else
      text      iprint ; ''
  endif
  print     [squash=yes ; iprint=#iprint] LOC, nReps, \
            powLN,powSQ,powPO,powOP,powNB ; fi=2(7),(10,8,8,8,8)1
  skip      [filetype=output] 1
endfor
stop
print   LOC, nReps, powLN, powSQ, powPO, powOP, powNB

stop
  if 1 " Checking "
    pointer   [nvalues=ndum] dummean, vdummean, chk
    tabulate  [class=id] zdum[] ; mean=dummean[]
    variate   vdummean[] ; dummean[] ; decimals=0
    calculate chk[] = sum(abs(qdum[] - vdummean[]))
    print     chk[]
  endif
  exit
endfor
stop



  fclassifi [out=modelH1] qdum[]

  " Include Modifiers/Blocks in model "
  if nModifiers
    duplicate Modifiers ; qModifiers ; values=!((#Modifiers)#iiReps)
    fclassifi [out=modelH1] #modelH1 + qModifiers
  endif
  if design.eqs.'block'
    fclassifi [out=modelH1] #modelH1 + qBlock
  endif

  " Define model for H0 "
  fclassifi [out=modelH0] #modelH1 - qdum[1]

  " Define offsets and Apply effect "
  calculate lowOffset = loglowerLOC * (qcomparison.eq.1)
  calculate uppOffset = logupperLOC * (qcomparison.eq.1)
  calculate qmean = ((1-qdum[1]) + qdum[1]*iiLOC) * qmean
  if 0
    print     qBlock, qPlot, Mean, qmean, qcomparison
  endif

  " Dummy fit to obtain degrees of freedom and critical values "
  model     [dist=poisson] qmean
  fit       [print=* ; nomes=lev,res,disp] #modelH1
  rkeep     df=df1
  calculate critvalChi = edchi(1-alfa ; 1)
  calculate critvalF = edf(1-alfa ; 1 ; df1)

  if 0  " Means of GMO and Comparator: averaging over Modifiers "
    predict   [print=* ; pred=pred ; back=link] qdum[] ; predval[]
    variate   vpred ; pred
    calculate ratio = vpred$[1]/vpred$[2]
    print     !t(GMO, Comparator), vpred, ratio, iiLOC
  endif

  " Effective replication for generalized confidence interval "
  calculate nCMP = sum(abs(qcomparison)) - (nGMO = sum(qdum[1]))

  " Structure to store results "
  variate   [nvalues=ndatasets ; values=#ndatasets(*)] efGMO, \
            fLN,fSQ,fOP,fNB, LNe,SQe,fOPe,fNBe ; deci=2
  variate   [nvalues=ndatasets ; values=#ndatasets(*)] exOP,exNB ; deci=0

  for [ntimes=ndatasets ; index=kk]
    " Simulate "
    calculate ranBlock = grnormal(iiReps ; 0 ; sig2Block)
    calculate qmeanBlock = qmean * exp(newlevels(qBlock ; ranBlock))
    cntgrando [dist=#dist] qmeanBlock ; dispersion=qsig2 ; numbers=yy
    \tabulate  [class=qfactors[1] ; print=mean] yy

    " Analyse  "
    if doLN.or.doSQ     " LN & SQ difference testing "
      calculate logyy = log(yy+1)
      calculate sqrtyy = sqrt(yy)
      model     logyy
      fit       [print=*] #modelH1
      rkeep     dev=qdev1[1] ; esti=qesti[1] ; se=qse[1]
      predict   [print=* ; pred=qpred[1] ; se=se[1]] qdum[] ; predval[]

      model     sqrtyy
      fit       [print=*] #modelH1
      rkeep     dev=qdev1[2] ; esti=qesti[2] ; se=qse[2]
      predict   [print=* ; pred=qpred[2]] qdum[] ; predval[]
      calculate (fLN, fSQ)$[kk] = (qesti[]$[2]/qse[]$[2])**2
      " Equivalence testing by means of GCI "
      calculate effRep = (qdev1[1]/df1)/(se[1]*se[1])
      equate    !p(qpred[1,2],effRep) ; !p(logGMO,logCMP,sqrGMO,sqrCMP,nGMO,nCMP)
      calculate GCIchi[1,2] = qdev1[1,2] / grchi(nGCI ; df1)
      calculate qlogGMO, qlogCMP, qsqrGMO, qsqrCMP = grnormal(nGCI ; \
                logGMO, logCMP, sqrGMO, sqrCMP ; 2(GCIchi[1,2])/(nGMO,nCMP))
      calculate qlogGMO, qlogCMP = \
                bound(exp(qlogGMO, qlogCMP + GCIchi[1]/2) - 1 ; 0.0001 ; mis)
      calculate qsqrGMO, qsqrCMP = qsqrGMO,qsqrCMP*qsqrGMO,qsqrCMP + GCIchi[2]
      calculate qlogGMO,qsqrGMO = qlogGMO,qsqrGMO / qlogCMP, qsqrCMP
      calculate logPerc, sqrPerc = percentiles(qlogGMO,qsqrGMO ; perc)
      calculate (LNe, SQe)$[kk] = ((logPerc,sqrPerc)$[1].gt.lowerLOC) .and. \
                ((logPerc,sqrPerc)$[2].lt.upperLOC)
    endif
    if doOP     " OP difference testing "
      calculate dev0,dev1 = mis
      model     [dist=poisson ; dispersion=*] yy
      terms     #modelH1
      fit       [print=*] #modelH1
      rkeep     dev=dev1 ; exit=exit ; esti=esti ; pear=pear1
      calculate efGMO$[kk] = (effGMO = esti$[2])
      calculate disp = pear1/df1
      drop      [print=*] qdum[1]
      rkeep     dev=dev0
      calculate exOP$[kk] = exit
      calculate fOP$[kk] = (dev0-dev1) / disp

      " OP equivalence Test "
      calculate dev0 = mis
      if (effGMO.le.loglowerLOC) .or. (effGMO.ge.logupperLOC)
          calculate fOPe$[kk] = 0
        elsif (effGMO.le.0)
          model     [dist=poisson ; dispersion=* ; offset=lowOffset] yy
          fit       [print=*] #modelH0
          rkeep     dev=dev0
          calculate fOPe$[kk] = (dev0-dev1) / disp
        elsif (effGMO.ge.0)
          model     [dist=poisson ; dispersion=* ; offset=uppOffset] yy
          fit       [print=*] #modelH0
          rkeep     dev=dev0
          calculate fOPe$[kk] = (dev0-dev1) / disp
        else
          FAULT   [diag=fault ; expl=!t('Not possible')]
      endif
    endif
    if doNB     " NB difference testing "
      calculate dev0,dev1 = mis
      model     [dist=negative ; link=log] yy
      r2negbin  [print=* ; _2log=dev1] #modelH1
      rkeep     exit=exit ; esti=esti
      calculate effGMO = esti$[1]
      r2negbin  [print=* ; _2log=dev0] #modelH0
      calculate exNB$[kk] = exit
      calculate fNB$[kk] = (dev0-dev1)

      " NB equivalence Test "
      calculate dev0 = mis
      if (effGMO.le.loglowerLOC) .or. (effGMO.ge.logupperLOC)
          calculate fNBe$[kk] = 0
        elsif (effGMO.le.0)
          model     [dist=negative ; link=log ; offset=lowOffset] yy
          r2negbin  [print=* ; _2log=dev0 ; constant=omit] #modelH0
          calculate fNBe$[kk] = (dev0-dev1)
        elsif (effGMO.ge.0)
          model     [dist=negative ; link=log ; offset=uppOffset] yy
          r2negbin  [print=* ; _2log=dev0 ; constant=omit] #modelH0
          calculate fNBe$[kk] = (dev0-dev1)
        else
          FAULT   [diag=fault ; expl=!t('Not possible')]
      endif
    endif
    \exit [co=for] (kk.eq.1)
  endfor
  calculate curLN,curSQ,curOP,curOPe,curNB,curNBe = \
            mean(fLN,fSQ,fOP,fOPe,fNB,fNBe.gt.4(critvalF),2(critvalChi))
  calculate (powLN,powSQ,powOP,powOPe,powNB,powNBe)$[ii] = \
            curLN,curSQ,curOP,curOPe,curNB,curNBe
  calculate (powLNe,powSQe)$[ii] = mean(LNe, SQe)
endfor

groups  LOC ; fLOC ; levels=levLOC
for [index=ii] ll=#levLOC
  restrict  nReps ; fLOC.eq.ll
  if (ii.eq.1)
      text      iprint ; 'id'
      skip      [filetype=output] 1
    else
      text      iprint ; ''
  endif
  print     [squash=yes ; iprint=#iprint] LOC, nReps, powLN,powSQ,powOP,powNB, \
            powLNe,powSQe,powOPe,powNBe ; fi=2(7),(10,8,8,8)2
  skip      [filetype=output] 1
endfor
stop
