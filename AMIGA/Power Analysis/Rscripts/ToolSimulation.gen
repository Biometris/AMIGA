"
  int[1] : difference between GMO and Comparator
  int[2] : common GMO and Comparator parameter
              int1  int2  int3  int4
  GMO            1     1     0     0
  Comparator     0     1     0     0
  V3             0     0     1     0
  V4             0     0     0     1
"

" Simulation settings "
scalar    cvBlock ; 10
scalar    cvComparator ; 40

scalar    lowerLOC ; 0.5
scalar    upperLOC ; 2.0
scalar    ngridLOC ; 9
variate   nBlocks ; !(10)
variate   nBlocks ; !(2,3,4)
scalar    ndatasets ; 2
scalar    nGCI ; 10000            " Number of draws for Gen. Conf. Interval "
scalar    alfa ; 0.05
scalar    limPowerDiff ; 2
scalar    seed ; 342894

scalar    power ; 1.5
text      distribution ; 'opoisson'
text      distribution ; 'power'
text      distribution ; 'poisson'
text      distribution ; 'negative'

text      models ; !t(LN,NB)
text      models ; !t(LN,SQ)
text      models ; !t(LN,SQ,OP)
text      models ; !t(LN,SQ,OP,NB)

" Import Data from Simulation tool "
text      file ; 'M:/My Documents/Default-0.csv'
import    file ; isave=isave
txconstru [tsave] isave
calculate posfactor[1,2] = position('Variety','Mean' ; tsave)  - (0,1)
variate   ifactor ; !(posfactor[1]...posfactor[2]) ; decimals=0
calculate nfactor = nvalues(ifactor)
groups    [redefine=yes] isave[#ifactor]
calculate nLevelsVariety = nlevels(Variety)
print     !p(isave[#ifactor])

groups    [redefine=yes] Block, MainPlot, SubPlot
calculate nplots = nvalues(Block)

" Define comparison "
variate   comparison ; (Comparison.in.'IncludeGMO') - \
          (Comparison.in.'IncludeComparator') ; decimals=0
restrict  Mean ; abs(comparison)
calculate meanComparator = mean(Mean)
restrict  Mean 

" Determine interaction factors and create dummies for Interaction*Variety "
calculate nInteractions = mean(NumberOfInteractions)
variate   cond ; !(1...#nfactor)
subset    [((cond-1).le.nInteractions)] ifactor ; intfactor
pointer   [values=isave[#intfactor]] intfactors
facproduc intfactors ; Interactions
calculate int[1] = comparison.in.1
calculate int[2] = abs(comparison)
subset    [int[2].eq.0 ; setlevels=yes] Interactions ; subInteractions
getattrib [attribute=levels,labels] subInteractions ; save=levels
scalar    counter ; 2
for ll=#levels['levels']
  calculate counter=counter+1
  calculate int[counter] = Interactions.in.ll
endfor
calculate nint = nvalues(int)
variate   [modify=yes] int[] ; decimals=0
if 1  " Printing of dummies for interaction "
  calculate nn = nvalues(intfactors)+1
  print     intfactors[], comparison, int[] ; field=#nn(12), #nint(7)
endif

" Determine Modifiers "
calculate nModifiers = mean(NumberOfModifiers)
if nModifiers
  subset    [ifactor.ni.intfactor] ifactor ; modfactor
  pointer   [values=isave[#modfactor]] modfactors
  facproduc modfactors ; Modifiers
  tabulate  [class=Modifiers] Mean ; mean=meanModifier
  if variance(meanModifier)
      " It is a true modifier "
      calculate nmod = nlevels(Modifiers)
      pointer   [nvalues=nmod] mod
      variate   mod[] ; decimals=0
      calculate mod[] = Modifiers.eq.(1...nmod)
    else
      calculate nModifiers, nmod = 0
  endif
endif
if 1*nModifiers  " Printing of dummies for modifiers "
  calculate nn = nvalues(modfactors)
  print     modfactors[], mod[] ; field=#nn(12), #nmod(7)
endif

" Combine regressors into a single pointer "
if nmod
    calculate nmod1 = nmod - 1
    pointer   [values=int[], mod[1...nmod1]] dum
  else
    pointer   [values=int[]] dum
endif
calculate ndum = nvalues(dum)

" Deal with distribution and Calculate overdispersion factor "
calculate cvPO = sqrt(Mean)/Mean
calculate sig2OP = (cvComparator/100)**2 * meanComparator
calculate cvOP = 100*sqrt(sig2OP*Mean)/Mean
calculate sig2NB = (cvComparator/100)**2 - 1/meanComparator
calculate cvNB = 100*sqrt(Mean + sig2NB*Mean*Mean)/Mean
calculate sig2PW = (cvComparator/100)**2 * meanComparator**(2-power)
calculate cvPW = 100*sqrt(sig2PW*Mean**power)/Mean
print     Mean, cvPO, cvOP, cvNB, cvPW
text      dist ; distribution
if distribution.eqs.'negative'
    calculate sig2, cvmean = sig2NB, cvNB
  elsif distribution.eqs.'opoisson'
    calculate sig2, cvmean = sig2OP, cvOP
  elsif distribution.eqs.'power'
    calculate cvmean = cvPW
    calculate sig2 = sig2PW*Mean**(power-2) - 1/Mean
    text      dist ; 'negative'
  elsif distribution.eqs.'poisson'
    calculate sig2,cvmean = mis,cvPO
    text      dist ; 'poisson'
  else
    fault     [diag=fault ; expl=!t('Wrong setting of distribution')]
endif
calculate sig2Block = log((cvBlock/100)**2 + 1)
print     dist, sig2, sig2Block

" Print effective replication "
calculate nCMP = sum(int[2]) - (nGMO = sum(int[1]))
variate   nRepsGMO, nRepsCMP ; nGMO,nCMP*nBlocks ; deci=0
print     nBlocks, nRepsGMO, nRepsCMP ; decimals=0

" Create grid for looping Loop over Loc/nBlocks values "
calculate loglowerLOC, logupperLOC = log(lowerLOC, upperLOC)
fgrid     [minimum=loglowerLOC ; maximum=logupperLOC ; ngrid=ngridLOC] gridLOC
calculate gridLOC[] = exp(gridLOC[])
fgrid     [values=gridLOC[], nBlocks] grid
variate   LOC, nReps ; grid[] ; deci=*,0
decimals  LOC

" Structures to store results "
calculate doLN, doSQ, doOP, doNB = 'LN', 'SQ', 'OP', 'NB' .in. models
calculate nloop = nvalues(LOC)
variate   [nvalues=nloop ; values=#nloop(*)] powLN, powSQ, powOP, powNB, \
          powOPe, powLNe, powSQe, powNBe ; deci=3

" Main looping "
for [ntimes=nloop ; index=ii]

  " Create Design for number of reps "
  scalar    iiLOC, iiReps ; (LOC, nReps)$[ii]
  dump iiReps,nplots
  calculate iiplots = iiReps*nplots
  factor    [nvalues=iiplots ; levels=iiReps] qBlock
  factor    [nvalues=iiplots ; levels=nplots] qPlot
  generate  qBlock, qPlot
  variate   [nvalues=iiReps] ranBlock
  pointer   [nvalues=ndum] qdum
  variate   [nvalues=iiplots] qdum[], qmean, qcomparison, qsig2, \
            yy, logyy, sqrtyy, qmeanBlock, lowOffset, uppOffset
  equate    Mean, comparison, sig2, dum[] ; qmean, qcomparison, qsig2, qdum[]

  " Define offsets and Apply effect "
  calculate lowOffset = loglowerLOC * (qcomparison.eq.1)
  calculate uppOffset = logupperLOC * (qcomparison.eq.1)
  restrict  qmean ; qcomparison.eq.1
  calculate qmean = iiLOC*qmean
  restrict  qmean
  if 0
    print     qBlock, qPlot, qmean, qcomparison
  endif

  " Define models  "
  fclassifi [out=modelH1] qdum[]
  fclassifi [out=modelH0] qdum[] - qdum[1]

  " Dummy fit to obtain degrees of freedom and critical values "
  model     qmean
  fit       [print=* ; constant=omit] #modelH1
  rkeep     df=df1
  calculate critvalChi = edchi(1-alfa ; 1)
  calculate critvalF = edf(1-alfa ; 1 ; df1)

  " Effective replication for generalized confidence interval "
  calculate nCMP = sum(qdum[2]) - (nGMO = sum(qdum[1]))

  " Structure to store results "
  variate   [nvalues=ndatasets ; values=#ndatasets(*)] efGMO, \
            fLN,fSQ,fOP,fNB, LNe,SQe,OPe,NBe ; deci=2
  variate   [nvalues=ndatasets ; values=#ndatasets(*)] exOP,exNB ; deci=0

  for [ntimes=ndatasets ; index=kk]
    " Simulate "
    calculate ranBlock = grnormal(iiReps ; 0 ; sig2Block)
    calculate qmeanBlock = qmean * exp(newlevels(qBlock ; ranBlock))
    cntgrando [dist=#dist] qmeanBlock ; dispersion=qsig2 ; numbers=yy
    \tabulate  [class=qfactors[1] ; print=mean] yy

    " Analyse  "
    if doLN.or.doSQ     " LN & SQ difference testing "
      calculate logyy = log(yy+1)
      calculate sqrtyy = sqrt(yy)
      model     logyy, sqrtyy
      terms     #modelH1
      fit       [print=* ; constant=omit] #modelH1
      rkeep     dev=qdev1[1,2] ; esti=qesti[1,2] ; se=qse[1,2]
      calculate (fLN, fSQ)$[kk] = (qesti[]$[1]/qse[]$[1])**2
      " Equivalence testing by means of GCI "
      calculate logGMO, logCMP = (1,0)*qesti[1]$[1] + qesti[1]$[2] 
      calculate sqrGMO, sqrCMP = (1,0)*qesti[2]$[1] + qesti[2]$[2] 
      calculate GCIchi[1,2] = qdev1[1,2] / grchi(nGCI ; df1)
      calculate qlogGMO, qlogCMP, qsqrGMO, qsqrCMP = grnormal(nGCI ; \
                logGMO, logCMP, sqrGMO, sqrCMP ; 2(GCIchi[1,2])/(nGMO,nCMP))
      calculate qlogGMO, qlogCMP = \
                bound(exp(qlogGMO, qlogCMP + GCIchi[1]/2) - 1 ; 0.0001 ; mis)
      calculate qsqrGMO, qsqrCMP = qsqrGMO,qsqrCMP*qsqrGMO,qsqrCMP + GCIchi[2]
      calculate qlogGMO,qsqrGMO = qlogGMO,qsqrGMO / qlogCMP, qsqrCMP
      calculate logPerc, sqrPerc = percentiles(qlogGMO,qsqrGMO ; perc)
      calculate (LNe, SQe)$[kk] = ((logPerc,sqrPerc)$[1].gt.lowerLOC) .and. \
                ((logPerc,sqrPerc)$[2].lt.upperLOC)
    endif
    if doOP     " OP difference testing "
      calculate dev0,dev1 = mis
      model     [distribution=poisson ; dispersion=*] yy
      terms     #modelH1
      fit       [print=* ; constant=omit] #modelH1
      rkeep     dev=dev1 ; exit=exit ; esti=esti
      calculate effGMO = esti$[1]
      calculate efGMO$[kk] = effGMO
      drop      [print=*] qint[1]
      rkeep     dev=dev0
      calculate exOP$[kk] = exit
      calculate fOP$[kk] = (dev0-dev1) / (dev1/df1)

      " OP equivalence Test "
      if (effGMO.le.loglowerLOC) .or. (effGMO.ge.logupperLOC)
          calculate OPe$[kk] = 0
        elsif (effGMO.le.0)
          model     [dist=poisson ; dispersion=* ; offset=lowOffset] yy
          fit       [print=* ; constant=omit] #modelH0
          rkeep     dev=dev0
          calculate Ftest = (dev0-dev1) / (dev1/df1)
          calculate OPe$[kk] = Ftest.gt.critvalF
        elsif (effGMO.ge.0)
          model     [dist=poisson ; dispersion=* ; offset=uppOffset] yy
          fit       [print=* ; constant=omit] #modelH0
          rkeep     dev=dev0
          calculate Ftest = (dev0-dev1) / (dev1/df1)
          calculate OPe$[kk] = Ftest.gt.critvalF
        else
          FAULT   [diag=fault ; expl=!t('Not possible')]
      endif
    endif
    if doNB     " NB difference testing "
      calculate dev0,dev1 = mis
      model     [distribution=negative ; link=log] yy
      r2negbin  [print=* ; _2log=dev1 ; constant=omit] #modelH1
      rkeep     exit=exit ; esti=esti
      calculate effGMO = esti$[1]
      r2negbin  [print=* ; _2log=dev0 ; constant=omit] #modelH0
      calculate exNB$[kk] = exit
      calculate fNB$[kk] = (dev0-dev1)

      " NB equivalence Test "
      if (effGMO.le.loglowerLOC) .or. (effGMO.ge.logupperLOC)
          calculate NBe$[kk] = 0
        elsif (effGMO.le.0)
          model     [dist=negative ; link=log ; offset=lowOffset] yy
          r2negbin  [print=* ; _2log=dev0 ; constant=omit] #modelH0
          calculate Chitest = (dev0-dev1)
          calculate NBe$[kk] = Chitest.gt.critvalChi
        elsif (effGMO.ge.0)
          model     [dist=negative ; link=log ; offset=uppOffset] yy
          r2negbin  [print=* ; _2log=dev0 ; constant=omit] #modelH0
          calculate Chitest = (dev0-dev1)
          calculate NBe$[kk] = Chitest.gt.critvalChi
        else
          FAULT   [diag=fault ; expl=!t('Not possible')]
      endif

    endif
    \exit [co=for] (kk.eq.1)
  endfor
  calculate curLN,curSQ,curOP,curNB = \
            mean(fLN,fSQ,fOP,fNB.gt.3(critvalF),critvalChi)
  calculate (powLN,powSQ,powOP,powNB)$[ii] = curLN,curSQ,curOP,curNB
  calculate (powOPe,powLNe,powSQe,powNBe)$[ii] = mean(OPe, LNe, SQe, NBe)
endfor

groups  LOC ; fLOC ; levels=levLOC
for [index=ii] ll=#levLOC
  restrict  nReps ; fLOC.eq.ll
  if (ii.eq.1)
      text      iprint ; 'id'
      skip      [filetype=output] 1
    else
      text      iprint ; ''
  endif
  print     [squash=yes ; iprint=#iprint] LOC, nReps, powLN,powSQ,powOP,powNB, \
            powLNe,powSQe,powOPe,powNBe ; fi=2(7),(10,8,8,8)2
  skip      [filetype=output] 1
endfor
stop
