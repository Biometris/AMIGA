enquire   ch=2 ; filetype=input  ; open=in2open  ; name=lylesfile
enquire   ch=3 ; filetype=input  ; open=in3open  ; name=infile
enquire   ch=2 ; filetype=output ; open=out2open ; name=outfile
close channel=2 ; filetype=output

\SET [WORKINGDIRECTORY='D:/Data/AMIGA/AmigaTool/Power Analysis/PowerAnalysis/Resources']

if in3open.eq.0
    text      project ; 'test-0'
    text      dir ; 'D:/Data/AMIGA/AmigaTool/TestData/'
    calculate pos = getposition(project ; '-')
    concatena [subdir] project ; width=getposition(project ; '-') - 1
    txconstru [infile] dir, subdir, '/', project, '.csv'
    open      infile ; channel=3 ; filetype=input
    sfilename [inputname=infile] directory=dir ; surname=sur
    txconstru [outfile] dir, sur, '-Output.csv'
    open      'D:/Data/AMIGA/AmigaTool/Power Analysis/PowerAnalysis/Resources/Lyles.pro' ; channel=2 ; filetype=input
    print     infile
    print     outfile
endif

" Include Lyles procedures "
input     [print=*] 2
close     channel=2 ; filetype=input


" Completely randomized than one loop is sufficient "

" Simulation settings "
" Import Data from Simulation tool "
text      [nvalues=1] dummy, distribution, design, method, IsLogNormal, \
          IsLogNormal, IsSquareRoot, IsOPoisson, IsNegBin
scalar    lowerLOC, upperLOC, cvComparator, cvBlock, powerdist, alfa, \
          ngridLOC, seed, ndatasets
variate   nBlocks
scalar    nitems ; 0
for read=lowerLOC, upperLOC, cvComparator, cvBlock, distribution, \
      powerdist, alfa, ngridLOC, nBlocks, design, method, seed, ndatasets, \
      IsLogNormal, IsSquareRoot, IsOPoisson, IsNegBin
  read    [print=* ; channel=3 ; end=*] dummy
  getattrib [attribute=stype] read ; save=att
  if att[].eqs.'variate'
      print 'variate'
      read    [print=# ; channel=3 ; setn=yes] read
    else
      read    [print=* ; channel=3] read
  endif
  calculate nitems = nitems + 2
endfor

calc lowerLOC,upperLOC=mvreplace(lowerLOC,upperLOC;1)

prin lowerLOC, upperLOC, cvComparator, cvBlock, distribution, \
      powerdist, alfa, ngridLOC, nBlocks, design, method, seed, ndatasets, \
      IsLogNormal, IsSquareRoot, IsOPoisson, IsNegBin

text      models, ismodels ; !t(LN,SQ,OP,NB)
equate    !t(#IsLogNormal, #IsSquareRoot, #IsOPoisson, #IsNegBin) ; ismodels
subset    [ismodels.in.'True'] models
print     models, ismodels
close     channel=3 ; filetype=input
fileread  [print=* ; name=infile ; skip=nitems ; imethod=read ; \
          separator=',' ; maxcat=0 ; isave=isave]
sreplace  ['OverdispersedPoisson' ; 'opoisson'] distribution
sreplace  ['PowerLaw' ; 'power'] distribution

sreplace  ['CompletelyRandomized' ; 'randomized'] design
sreplace  ['RandomizedCompleteBlocks' ; 'block'] design
sreplace  ['SplitPlot' ; 'splitplot'] design

prin isave

" Some extra options "
calculate init = urand(seed ; 1)

" Create design matrix from input file "
L1CREATE  [isave] MUCOMPARATOR=meanComparator ; MEAN=zz ; COMPARISON=comparison ; \
          DUMMY=dum ; MODIFIERS=Modifiers

" create grid for looping loop over loc/nblocks values "
" for a randomized design the non-centrality parameter is proportional "
calculate loglowerloc, logupperloc = log(lowerLOC, upperLOC)
fgrid     [min=loglowerloc ; max=logupperloc ; ngrid=ngridLOC] gridratio
calculate gridratio[] = exp(gridratio[])
if flagRan = (design.eqs.'randomized') .or. (cvBlock.eq.0)
    variate   ratio ; gridratio[]
    variate   nreps ; 2 + 0*ratio
  else
    fgrid     [values=gridratio[], nBlocks] grid
    variate   ratio, nreps ; grid[] ; deci=*,0
endif

calculate nloop = nvalues(ratio)
decimals  ratio

" main looping "
for [ntimes=nloop ; index=ii]
  scalar    iiratio, iireps ; (ratio, nreps)$[ii]
  PRINT     [IPRINT=* ; SQUASH=yes] iiratio, iireps ; FIELD=10 ; DECI=3,0
  l2lyles   [dist=#distribution ; power=powerdist ; design=#design ; sign=alfa ; \
            mucomp=meanComparator ; cvcomp=cvComparator ; cvblock=cvBlock ; \
            mean=Mean ; comparison=comparison ; dummy=dum ; \
            modifiers=Modifiers ; loclower=lowerLOC ; locupper=upperLOC ; \
            analysis=#models] iiratio ; iireps ; qnc[ii] ; qpow[ii] ; qdf[ii]
endfor
variate   df ; !(#qdf) ; deci=0
vequate   qnc,qpow ; nc,pow

" Expand for randomized "
print flagRan
if flagRan
  scalar    nplots ; nvalues(Mean)
  calculate npars = 2*nplots - mean(df)
  fgrid     [values=ratio, nBlocks] grid
  variate   ratio, nreps ; grid[]
  groups    ratio, nreps ; fRatio, fReps
  tabulate  [class=fRatio, fReps] nplots*fReps - npars ; mean=tdf
  variate   df ; tdf ; decimals=0

  pointer   [nvalues=nvalues(nc)] tnc, ttnc, pow
  table     [class=fRatio] tnc[] ; nc[]
  table     [class=fRatio, fReps] tNreps, ttnc[]
  tabulate  1*fReps ; mean=tNreps
  calculate ttnc[] = tnc[] * tNreps/2
  variate   nc[] ; ttnc[]
  calculate critvalChi = edchi(1-alfa + 0*df ; 1)
  calculate critvalF = edf(1-alfa + 0*df ; 1 ; df)
  for [index=ii] qq=nc[] ; pp=pow[] ; type=2,2,1,2,1
    if (type.eq.1)
        variate   pp ; CUCHI(critvalChi ; 1 ; qq)
      else
        variate   pp ; CUF(critvalF ; 1 ; df ; qq)
    endif
  endfor
endif
print   nc[1...5,8,9,10] ; fi=10 ; de=3
print   pow[1...5,8,9,10] ; fi=10 ; de=3

" Export "
text      names ; !t(\
          Ratio, \
          LogRatio, \
          NumberReplicates, \
          PowerDifferenceLogNormal, \
          PowerDifferenceSquaredRoot, \
          PowerDifferenceOverdispersedPoisson, \
          PowerDifferenceNegativeBinomial, \
          PowerEquivalenceLogNormal, \
          PowerEquivalenceSquaredRoot, \
          PowerEquivalenceOverdispersedPoison, \
          PowerEquivalenceNegativeBinomial)

calculate logratio = log(ratio)
export    [outfile=outfile ; method=overwrite] \
          ratio, logratio, nreps, pow[1,2,4,5, 6,7,9,10] ; columns=#names

stop
